{"ast":null,"code":"// Simple IndexedDB-based offline queue for scan records.\n// Minimal promise wrapper for storing pending scans and syncing when online.\n\nfunction openDB() {\n  return new Promise((resolve, reject) => {\n    const req = window.indexedDB.open('ecocollect_offline_v1', 1);\n    req.onupgradeneeded = ev => {\n      const db = ev.target.result;\n      if (!db.objectStoreNames.contains('scans')) {\n        db.createObjectStore('scans', {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n      }\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\nasync function withStore(mode, fn) {\n  const db = await openDB();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction('scans', mode);\n    const store = tx.objectStore('scans');\n    let done = false;\n    tx.oncomplete = () => {\n      if (!done) resolve();\n    };\n    tx.onerror = () => reject(tx.error || new Error('Transaction error'));\n    try {\n      const result = fn(store);\n      // If fn returns a request, wire its events\n      if (result && typeof result.onsuccess !== 'undefined') {\n        result.onsuccess = e => {\n          done = true;\n          resolve(e.target.result);\n        };\n        result.onerror = e => {\n          done = true;\n          reject(e.target.error);\n        };\n      } else if (result instanceof Promise) {\n        result.then(r => {\n          done = true;\n          resolve(r);\n        }).catch(err => {\n          done = true;\n          reject(err);\n        });\n      } else if (typeof result !== 'undefined') {\n        done = true;\n        resolve(result);\n      }\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\nexport async function saveScan(scan) {\n  return withStore('readwrite', store => store.add(scan));\n}\nexport async function getAllScans() {\n  return withStore('readonly', store => new Promise((resolve, reject) => {\n    const req = store.getAll();\n    req.onsuccess = () => resolve(req.result || []);\n    req.onerror = () => reject(req.error);\n  }));\n}\nexport async function deleteScan(id) {\n  return withStore('readwrite', store => store.delete(id));\n}\n\n// Attempt to POST pending scans to backend; delete on success.\nexport async function syncPendingScans() {\n  const scans = await getAllScans();\n  if (!scans.length) return {\n    synced: 0\n  };\n  let synced = 0;\n  for (const s of scans) {\n    try {\n      // Try to POST to backend; adjust URL as needed\n      const res = await fetch('/api/collections/scan', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(s.payload || s)\n      });\n      if (res.ok) {\n        await deleteScan(s.id);\n        synced += 1;\n      }\n    } catch (e) {\n      // network error — stop and return\n      console.warn('syncPendingScans network error', e);\n      return {\n        synced\n      };\n    }\n  }\n  return {\n    synced\n  };\n}\nexport function initOfflineSync(options = {}) {\n  const intervalMs = options.intervalMs || 30000; // periodic attempt\n  // Try to sync when back online\n  window.addEventListener('online', () => {\n    // fire and forget\n    syncPendingScans().then(r => console.log('Offline sync ononline result', r)).catch(e => console.warn(e));\n  });\n  // Periodic sync while app is open\n  const id = setInterval(() => {\n    if (navigator.onLine) syncPendingScans().catch(() => {});\n  }, intervalMs);\n  return () => clearInterval(id);\n}\nexport default {\n  saveScan,\n  getAllScans,\n  deleteScan,\n  syncPendingScans,\n  initOfflineSync\n};","map":{"version":3,"names":["openDB","Promise","resolve","reject","req","window","indexedDB","open","onupgradeneeded","ev","db","target","result","objectStoreNames","contains","createObjectStore","keyPath","autoIncrement","onsuccess","onerror","error","withStore","mode","fn","tx","transaction","store","objectStore","done","oncomplete","Error","e","then","r","catch","err","saveScan","scan","add","getAllScans","getAll","deleteScan","id","delete","syncPendingScans","scans","length","synced","s","res","fetch","method","headers","body","JSON","stringify","payload","ok","console","warn","initOfflineSync","options","intervalMs","addEventListener","log","setInterval","navigator","onLine","clearInterval"],"sources":["C:/Users/udith/OneDrive/Desktop/CSSE/EcoCollect/apps/frontend/src/lib/offline.js"],"sourcesContent":["// Simple IndexedDB-based offline queue for scan records.\r\n// Minimal promise wrapper for storing pending scans and syncing when online.\r\n\r\nfunction openDB() {\r\n  return new Promise((resolve, reject) => {\r\n    const req = window.indexedDB.open('ecocollect_offline_v1', 1);\r\n    req.onupgradeneeded = (ev) => {\r\n      const db = ev.target.result;\r\n      if (!db.objectStoreNames.contains('scans')) {\r\n        db.createObjectStore('scans', { keyPath: 'id', autoIncrement: true });\r\n      }\r\n    };\r\n    req.onsuccess = () => resolve(req.result);\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n\r\nasync function withStore(mode, fn) {\r\n  const db = await openDB();\r\n  return new Promise((resolve, reject) => {\r\n    const tx = db.transaction('scans', mode);\r\n    const store = tx.objectStore('scans');\r\n    let done = false;\r\n    tx.oncomplete = () => { if (!done) resolve(); };\r\n    tx.onerror = () => reject(tx.error || new Error('Transaction error'));\r\n    try {\r\n      const result = fn(store);\r\n      // If fn returns a request, wire its events\r\n      if (result && typeof result.onsuccess !== 'undefined') {\r\n        result.onsuccess = (e) => { done = true; resolve(e.target.result); };\r\n        result.onerror = (e) => { done = true; reject(e.target.error); };\r\n      } else if (result instanceof Promise) {\r\n        result.then((r) => { done = true; resolve(r); }).catch((err) => { done = true; reject(err); });\r\n      } else if (typeof result !== 'undefined') {\r\n        done = true; resolve(result);\r\n      }\r\n    } catch (err) {\r\n      reject(err);\r\n    }\r\n  });\r\n}\r\n\r\nexport async function saveScan(scan) {\r\n  return withStore('readwrite', (store) => store.add(scan));\r\n}\r\n\r\nexport async function getAllScans() {\r\n  return withStore('readonly', (store) => new Promise((resolve, reject) => {\r\n    const req = store.getAll();\r\n    req.onsuccess = () => resolve(req.result || []);\r\n    req.onerror = () => reject(req.error);\r\n  }));\r\n}\r\n\r\nexport async function deleteScan(id) {\r\n  return withStore('readwrite', (store) => store.delete(id));\r\n}\r\n\r\n// Attempt to POST pending scans to backend; delete on success.\r\nexport async function syncPendingScans() {\r\n  const scans = await getAllScans();\r\n  if (!scans.length) return { synced: 0 };\r\n  let synced = 0;\r\n  for (const s of scans) {\r\n    try {\r\n      // Try to POST to backend; adjust URL as needed\r\n      const res = await fetch('/api/collections/scan', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify(s.payload || s),\r\n      });\r\n      if (res.ok) {\r\n        await deleteScan(s.id);\r\n        synced += 1;\r\n      }\r\n    } catch (e) {\r\n      // network error — stop and return\r\n      console.warn('syncPendingScans network error', e);\r\n      return { synced };\r\n    }\r\n  }\r\n  return { synced };\r\n}\r\n\r\nexport function initOfflineSync(options = {}) {\r\n  const intervalMs = options.intervalMs || 30_000; // periodic attempt\r\n  // Try to sync when back online\r\n  window.addEventListener('online', () => {\r\n    // fire and forget\r\n    syncPendingScans().then((r) => console.log('Offline sync ononline result', r)).catch((e) => console.warn(e));\r\n  });\r\n  // Periodic sync while app is open\r\n  const id = setInterval(() => {\r\n    if (navigator.onLine) syncPendingScans().catch(() => {});\r\n  }, intervalMs);\r\n  return () => clearInterval(id);\r\n}\r\n\r\nexport default { saveScan, getAllScans, deleteScan, syncPendingScans, initOfflineSync };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}